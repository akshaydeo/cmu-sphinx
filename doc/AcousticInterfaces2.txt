
------------------- package private data ---------------
This is the next level down of the AcousticModel interfaces. It shows
some of the concrete implementations of the abstract interfaces
described  in the 'high-level' interfaces document. These classes are
to be defined as 'package private' and will not be visible outside of
the Acoustic Model package.

Note that these structures are built from components that may be
shared with other objects of the same type. For instance, Several
mixture components may share the same meanTransformationMatrix.  These
shared components are maintained in pools.  It is up to the acoustic
model loader to create and manage these component pools and manage the
sharing of these objects.  The acoustic model loader and the pool
manager will be described in a subsequent step.

There are some questions embedded. Here is the key:

  - [[[QFSE - this marks a "Question For Speech Expert"]]]
  - [[[QFJE - this marks a "Question For Java Expert"]]]


[[[ QFSE - Is there enough precision in a Java float (32 bits) to
    represent the GaussianMixture data and the resulting score? Note
    that java floats are essentially 32-bit IEEE 754 values, and java
    doubles are 64-bit IEEE 754 values.

    Float
    	bits of precision:		24
	Exponent bits:			8
	Decimal digits of precision:	7.22
	Maximum Magnitude:		3.4028E+38
	Minimum Magnitude:		1.1754E-38

    Double
    	bits of precision:		53
	Exponent bits:			11
	Decimal digits of precision:	15.95
	Maximum Magnitude:		1.7976E+308
	Minimum Magnitude:		2.2250E-308
]]]


[[[ QFSE QFJE - Many of my questions have to do with Acoustic Model
adaptation. We have not talked yet to any depth about adaptation, so I
do not have a good feel for how it would work or how to provide an
interface for it. Perhaps we can just chose to acknowledge that we
will do some adaptation of models in the future, but for the short
term not worry too much about constructing interfaces to it. Any
thoughts?
]]]

/**
 * 
 * Represents a concrete implementation of a simple senone. A simple
 * senone is a set of probability density functions implemented  as a
 * gaussian mixture.
 */
class GaussianMixture implements Senone {
    // these data element in a senone may be shared with other senones
    // and therefore should not be written to.
    private float[] mixtureWeights;			
    private MixtureComponent[] mixtureComponents;	

    /**
     * Creates a new senone from the given components.
     *
     * @param mixtureWeights the mixture weights for this senone
     * @param  mixtureComponents the mixture comopnents for this
     * senone
     */
    public GaussianMixture(float[] mixtureWeights, 
    		MixtureComponent[] mixtureComponents);

    
    /**
     * Calculates a score for the given feature based upon this senone
     *
     * @param feature the feature to score
     *
     * @return the score for the feature
     */
    public float getScore(Feature feature); 

    /* [[[ QFSE - I assume that mixtureWeights are used for adaptation.
    Is this correct? What would be an approriate interface for
    modifying mixture weights? Perhaps something as simple as this:

    public float getMixtureWeights();
    public void setMixtuerWeights(float[] mixtureWeights);

    ]]] */
}


/**
 * Represents a composite senone. A composite senone consists of a set
 * of all possible senones for a given state
 */
 [[[ QFSE - Note that there is no CompositeSenoneSequence class.
 Instead there is just a SenoneSequence class that represents
 sequences of senones (simple or composite). This would allow us to
 easily represent sequences that are mixtures of simple and composite
 sequences.  The question is: Is there any reason to maintain
 CompositeSeneoneSequences explicitly and separately from
 SimpleSenone sequences?
 ]]]

class CompositeSenone implements Senone {
    private Senone[] senones;


    /**
     * Constructs a CompositeSenone given the set of constiuent
     * senones
     *
     * @param senones the set of constiuent senones
     *
     */
    public CompositeSenone(Senone[] senones);

    /**
     * Calculates the composite senone score. Typically this is the
     * best score for all of the constituent senones
     *
     * @param feature the feature to score
     *
     * @return the score for the feature
     */
    public float getScore(Feature feature);
}


/**
 * defines the set of shared elements for a GaussianMixture. Since
 * these elements are potentially shared by a number of
 * GaussianMixtures, these elements should not be written to. The
 * GaussianMixture defines a single probability density function along
 * with a set of adaptation parameters 
 *
 */
 // [[[ QFSE: I'm still a bit unsure
 //  of the role of the Transformation Matrices and Vectors, are 
 // these use for adaptation?  ]]]

 // [[[ QFSE: Since many of the subcomponents of a
 // MixtureComponent are shared, are there some potential
 // opportunities to reduce the number of computations in scoring
 // senones by sharing intermediate results for these subcomponents?
 //  ]]]

class MixtureComponent {
    private float[]   mean;
    private float[][] meanTransformationMatrix;
    private float[]   meanTransformationVector;
    private float[]   variance;
    private float[][] varianceTransformationMatrix

    /**
     * Create a MixtureComponent with the given sub components
     *
     * @param mean	the mean vector for this PDF
     * @param meanTransformationMatrix TBD NOT SURE
     * @param meanTransformationVector TBD NOT SURE
     * @param variance  the variance for this PDF
     * @param varianceTransformationMatrix  TBD NOT SURE
     */
    MixtureComponent(
	private float[]   mean;
	private float[][] meanTransformationMatrix;
	private float[]   meanTransformationVector;
	private float[]   variance;
	private float[][] varianceTransformationMatrix); 

    // [[[ QFSE QFJE
    // I'm not sure of the best interface for this class, that depends
    // on how the GaussianMixture.getScore method wants to be written.
    // Some options are (given in order of preference):
    //
    // push the scoring down to this level:
    //
    //		float getScore(Feature feature)
    //
    //  provide accessor methods to all elements, like so:
    //
    //		float[] getMean()
    //		float[] getMeanTransformationMatrix()
    //		float[] getMeanTransformationVector()
    //		float[] getVariance()
    //		float[] getVarianceTransformationMatrix()
    //
    //
    // Or provide direct access to the elements, (that is, remove the
    // 'private' qualifier from the data declarations in this class.)
    // ]]]

    /**
     * Score this mixture against the given feature
     *
     * @param feature the feature to score
     *
     * @return the score for the given feature
     */
     float getScore(Feature feature);

     // [[[ QFSE: Once again, I am not sure what the proper adaptation
     // interface should look like. We really have not talked enough
     // about adaptation at this point for us to decide on an
     // interface for it. I'll just leave it out for now.
}
