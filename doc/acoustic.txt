Will has asked me to look at the interfaces for the Acoustic Model.  I've been
looking at the Acoustic Model structures as Will has laid out in the Architecture.
I am trying to reconcile these structures with the discussion we had on Friday about
the Viterbi-One-Step approach to decoder design.

This is an attempt to briefly describe what the Viterbi-one-step does with an eye to
understand the interfaces between it and the Acoustic Model.  I understand that the
Viterbi-one-step is still in early design stage, nevertheless, we should probably be
able to glean something about its interfaces with the Acoustic Model.

One Step Viterbi
----------------
This Viterbi Decoder manages a set of active states per each frame. A frame is just
one tick at a time.  At each tick the viterbi decoder does the following:

 - Give the list of active states to the language model/history box

 - Gets back a list of new active states. Each state contains a pointer to a single
   senone, a transition matrix that details the probability that this state can be
   transitioned reached from each of the previous states, and some flags that tell 
   us whether this is state is associated with the end of a unit or
   word.  This is a fuzzy bit (at least in my mind) with regard to the Acoustic
   Model. The language/model/history box will need to generate this list of states.
   These states are finer grained (at the senone level recall), then hmms.  ZZ

 - Scores the senones - The decoder then collects all the senones into a single 
   set and sends them to the 'SenoneScorer'. This box scores the senones based 
   upon MixtureWeights and MixtureComponents as outlined in the Achitecture document.
   This is one interface between the Viterbi-one-step and the acoustic model. It
   could look something like this:

   	SenoneSetScores AcousticModel.scoreSenones(SenoneSet setOfSenones);


 - Prunes the states - The states are pruned based upon the senone scores,
   transition probabilities, unit and word



The scoring of the states was managed by the 'acoustic model' box. This box
would take a set of senones, and the FeatureVector for the current frame  and return
a set of scores associated with the senones.  The Viterbi decoder would then prune
the current states based upon these scores.

Some Notes:
  - The Senone Scoring can be a fairly expensive operation. Every tick there can be
    a large number of senones to score. There are a fairly large number of floating
    point operations required to score each senone.  Subvector quantization may be
    used to reduce the set of senones that need to be scored.

  - The Senone Scoring is potentially one of the processing bottlenecks in the
    recognizer. However, due to the nature of how senones are scored, it may be
    possible to spread the scoring among a number of threads (and consequently, a
    number of processors when running on a multi-CPU machine). The interface to the
    SenoneScorer should allow for a multithreaded implementation.
