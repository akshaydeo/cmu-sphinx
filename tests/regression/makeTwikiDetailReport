
# Copyright 1999-2002 Carnegie Mellon University.  
# Portions Copyright 2002 Sun Microsystems, Inc.  
# Portions Copyright 2002 Mitsubishi Electronic Research Laboratories.
# All Rights Reserved.  Use is subject to license terms.
# 
# See the file "license.terms" for information on usage and
# redistribution of this file, and for a DISCLAIMER OF ALL 
# WARRANTIES.
#
# This script parses the regression log and outputs a detailed
# regression report suitable for a twiki
#
# usage: ./makeTwikiDetailReport regression.log listoftests.list
#     machine typeOfResults  title recognizer 
#
# Field definitions: 
#   1) "test"
#   2) date
#   3) time
#   4) machine
#   5) System
#   6) testName 
#   7) who 
#   8) status
#   9) audioTime 
#  10) procTime 
#  11) words 
#  12) insertions 
#  13) deletions 
#  14) substitutions 
#  15) sentences 
#  16) correctSentences 
#  17) heapSize 
#  18) loadAverage 

gawk '

BEGIN {
    FS = "|"
    F_TEST = 1;
    F_DATE = 2;
    F_TIME = 3;
    F_MACHINE = 4;
    F_SYSTEM = 5;
    F_TEST_NAME = 6;
    F_WHO = 7;
    F_STATUS = 8;
    F_AUDIO_TIME = 9;
    F_PROC_TIME = 10;
    F_WORDS = 11;
    F_INSERTIONS = 12;
    F_DELETIONS = 13;
    F_SUBSTITUTIONS = 14;
    F_SENTENCES = 15;
    F_CORRECT_SENTENCES = 16;
    F_HEAP_SIZE = 17;
    F_LOAD_AVERAGE = 18;

    NOT_AVAILABLE = "n/a";

# usage makeTwikiDetailReport log test.list machine mode title system
    testList = ARGV[2];
    machine = ARGV[3];
    mode = ARGV[4];
    title = ARGV[5];
    whichSystem = ARGV[6];

    if (machine == "this") {
	"hostname" | getline hostname;
	machine = hostname
    }


    ARGV[6] = "";
    ARGV[5] = "";
    ARGV[5] = "";
    ARGV[4] = "";
    ARGV[3] = "";
    ARGV[2] = "";

    systemName[0] = "s3";
    systemName[1] = "s3.3";
    systemName[2] = "s4";

    systemTitle["s3"] = "Sphinx 3";
    systemTitle["s3.3"] = "Sphinx 3.3";
    systemTitle["s4"] = "Sphinx 4";
    systemCount = 3;


    modeTitle["latest"] =  "Latest detailed ";
    modeTitle["fastest"] = "Fastest detailed ";
    modeTitle["best"] =    "Most accurate detailed ";

    # read in the test list

    # parse the s4 align summary output
    totalTestCount = 0;
    while (getline x < testList > 0) {
	if (match(x, "#") != 1) {
	    tests[x] = 1;
	    testOrder[totalTestCount++] = x;
	}
    }
    close(testList);
}

$F_TEST == "test"  && ($F_MACHINE == machine || machine == "any") \
	&& ($F_TEST_NAME in tests || testList == "any") && \
	   ($F_SYSTEM == whichSystem) {
    tag = $F_TEST_NAME;
    if (mode == "latest") {
        testData[tag] = $0;
    } else if (mode == "fastest") {
        speed = getSpeedFromLine($0);
	if (speed != NOT_AVAILABLE) {
	    if (!(tag in bestSpeed) || speed < bestSpeed[tag]) {
	        bestSpeed[tag] = speed;
		testData[tag] = $0;
	    }
	}
    } else if (mode == "best") {
        accuracy = getAccuracyFromLine($0);
	if (accuracy != NOT_AVAILABLE) {
	    if (!(tag in bestAccuracy) || accuracy < bestAccuracy[tag]) {
	        bestAccuracy[tag] = accuracy;
		testData[tag] = $0;
	    }
	}
    }

    if (testList == "any") {
        tests[$F_TEST_NAME] = 1;
    }
}


#####
# updates the data array with info for the given test
#
function updateData(testName, testCount) {
    split(testData[testName testCount], data);
}


####
# returns the speed for the given test/system
#
function getSpeedFromLine(line) {
     split(line, data);
    _audioTime = data[F_AUDIO_TIME];
    _procTime = data[F_PROC_TIME];

    if (_audioTime == "" || _procTime == "") {
         return NOT_AVAILABLE;
    } else {
	return _procTime / _audioTime;
    }
}

function getSpeed(testName) {
     return getSpeedFromLine(testData[testName]);
}

####
# returns the accuracy for the given test/system
#
function getAccuracyFromLine(line) {
     split(line, data);
    _errors = data[F_INSERTIONS] + data[F_DELETIONS] + data[F_SUBSTITUTIONS];
    _words = data[F_WORDS];

    if (_words == "" || _words == 0) {
        return NOT_AVAILABLE;
    } else {
	return _errors / _words * 100;
    }
}

function getAccuracy(testName) {
     return getAccuracyFromLine(testData[testName]);
}

function get(testName, field) {
# very inefficient, but fast enough for what we are doing
    split(testData[testName], _data);
    _val = _data[field];
    if (_val == "")  {
        return NOT_AVAILABLE;
    } else {
        return _val;
    }
}

function getPercent(num, denom) {
    if (denom != NOT_AVAILABLE && denom !=  0) {
         return (num / denom) * 100.0;
    } else {
        return NOT_AVAILABLE;
    }
}

####
# Dumps data for a single test
#

function dumpTest(testName) {
   printf("|<font color=#018888> %s </font>", testName);
   printf("|%s", getSpeed(testName));
   words = get(testName, F_WORDS);
   printf("|%s", words);
   printf("|%s", getPercent(get(testName, F_INSERTIONS), words));
   printf("|%s", getPercent(get(testName, F_DELETIONS), words));
   printf("|%s", getPercent(get(testName, F_SUBSTITUTIONS), words));
   printf("|%s", getAccuracy(testName));
   sentences = get(testName, F_SENTENCES);
   printf("|%s", sentences);
   correctSentences = get(testName, F_CORRECT_SENTENCES);
   sentencesWithErrors = sentences - correctSentences;
   printf("|%s", sentencesWithErrors);
   printf("|%s", getPercent(sentencesWithErrors, sentences));
   printf("|\n");
}


#######
# Dumps the title
# 
function dumpTitle(  i) {

    if (machine == "any") {
        machineName = "all systems";
    } else {
        machineName = machine;
    }

    printf("|   *%s %s for %s*  ||||||||||\n", modeTitle[mode], \
        title, systemTitle[whichSystem]);

    printf("| *%s %s* ", "Test run on", machineName);
    printf("| *%s* ", "Speed (RT)");
    printf("| *%s* ", "Num Words");
    printf("| *%s* ", "Insertions (%)");
    printf("| *%s* ", "Deletions (%)");
    printf("| *%s* ", "Substitutions (%)");
    printf("| *%s* ", "Word Error Rate (%)");
    printf("| *%s* ", "Num Sentences");
    printf("| *%s* ", "Sentences with Errors");
    printf("| *%s* ", "Sentence Error Rate");
    printf("|\n");
}

END {
    # If test list is any then we synthesize the test order

    if (testList == "any") {
	totalTestCount = 0;
        for (i in tests) {
	    testOrder[totalTestCount++] = i;
	}
    }

    dumpTitle();
    for (i = 0; i < totalTestCount; i++) {
        dumpTest(testOrder[i]);
    }

# Make the page read-only so people do not try to edit these pages

    print "<small>"
    print "_This table is automatically generated. Do not edit this by hand._";
    print "</small>"
    print "<!--";
    print "Set DENYTOPICCHANGE=Main.SphinxGroup SphinxGroup";
    print "  -->";

}

'  $*

