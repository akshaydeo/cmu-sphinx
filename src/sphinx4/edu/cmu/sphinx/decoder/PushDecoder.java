/*
 *
 * Copyright 1999-2004 Carnegie Mellon University.
 * Portions Copyright 2004 Sun Microsystems, Inc.
 * Portions Copyright 2004 Mitsubishi Electric Research Laboratories.
 * All Rights Reserved.  Use is subject to license terms.
 *
 * See the file "license.terms" for information on usage and
 * redistribution of this file, and for a DISCLAIMER OF ALL
 * WARRANTIES.
 *
 */
package edu.cmu.sphinx.decoder;

import edu.cmu.sphinx.decoder.search.SearchManager;
import edu.cmu.sphinx.frontend.*;
import edu.cmu.sphinx.frontend.endpoint.SpeechEndSignal;
import edu.cmu.sphinx.frontend.endpoint.SpeechStartSignal;
import edu.cmu.sphinx.result.Result;
import edu.cmu.sphinx.result.ResultListener;
import edu.cmu.sphinx.util.props.PropertyException;
import edu.cmu.sphinx.util.props.PropertySheet;
import edu.cmu.sphinx.util.props.S4Component;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;


/**
 * A decoder which does not use the common pull-principle of S4 but recognizes frame-wise (aka push-principle). When
 * using this decoder, make sure that the scorer used by the <code>searchManager</code> can access some buffered
 * <code>Data</code>s. This can be achieved e.g. by inserting the a data-buffer right before this component in the
 * feature-frontend.
 */
public class PushDecoder extends BaseDataProcessor implements ResultProducer {

    /** The sphinx property name for the name of the search manager to use */
    @S4Component(type = SearchManager.class)
    public final static String PROP_SEARCH_MANAGER = "searchManager";
    private SearchManager searchManager;


    private List<ResultListener> resultListeners = new ArrayList<ResultListener>();
    private boolean isRecognizing;
    public Result result;


    public void newProperties(PropertySheet ps) throws PropertyException {
        super.newProperties(ps);

        searchManager = (SearchManager) ps.getComponent(PROP_SEARCH_MANAGER);

        try {
            allocate();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    public Data getData() throws DataProcessingException {
        Data d = getPredecessor().getData();

        if (isRecognizing && (d instanceof FloatData || d instanceof DoubleData)) {
            result = decode(null);

            if (result != null && result.isFinal()) {
                fireResultListeners(result);
                result = null;
            }
        }

        if (d instanceof SpeechStartSignal) {
            searchManager.startRecognition();
            isRecognizing = true;
            result = null;
        }

        if (d instanceof SpeechEndSignal) {
            searchManager.stopRecognition();

            //fire results which were not yet final
            if (result != null)
                fireResultListeners(result);

            isRecognizing = false;
        }

        return d;
    }


    /**
     * Decode frames until recognition is complete
     *
     * @param referenceText the reference text (or null)
     * @return a result
     */
    public Result decode(String referenceText) {
        return searchManager.recognize(1);
    }


    /** Allocate resources necessary for decoding */
    public void allocate() throws IOException {
        searchManager.allocate();
    }


    /** Deallocate resources */
    public void deallocate() {
        searchManager.deallocate();
    }


    /**
     * Adds a result listener to this recognizer. A result listener is called whenever a new result is generated by the
     * recognizer. This method can be called in any state.
     *
     * @param resultListener the listener to add
     */
    public void addResultListener(ResultListener resultListener) {
        resultListeners.add(resultListener);
    }


    /**
     * Removes a previously added result listener. This method can be called in any state.
     *
     * @param resultListener the listener to remove
     */
    public void removeResultListener(ResultListener resultListener) {
        resultListeners.remove(resultListener);
    }


    /**
     * fires the new result event
     *
     * @param result the new result
     */
    private void fireResultListeners(Result result) {
        for (ResultListener resultListener : resultListeners) {
            resultListener.newResult(result);
        }
    }

}
